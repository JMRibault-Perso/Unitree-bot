<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>G1 Robot Controller - Professional UI</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #764ba2;
            --success: #48bb78;
            --danger: #f56565;
            --warning: #ed8936;
            --bg-dark: #0f1419;
            --bg-panel: #1a1f2e;
            --text-light: #e0e0e0;
            --text-muted: #718096;
        }

        body {
            background: var(--bg-dark);
            color: var(--text-light);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            overflow: hidden;
        }

        .container {
            display: grid;
            grid-template-columns: 240px 1fr 350px;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            gap: 0;
        }

        /* TOP BAR */
        .top-bar {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            gap: 20px;
        }

        .robot-info {
            display: flex;
            gap: 30px;
            flex: 1;
            align-items: center;
        }

        .robot-name {
            font-size: 18px;
            font-weight: 600;
            color: var(--primary);
        }

        .status-badge {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            padding: 4px 12px;
            background: rgba(72, 187, 120, 0.1);
            border: 1px solid var(--success);
            border-radius: 4px;
            color: var(--success);
        }

        .status-badge.offline {
            background: rgba(245, 101, 101, 0.1);
            border-color: var(--danger);
            color: var(--danger);
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .status-badge.offline .status-dot {
            background: var(--danger);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .telemetry-badges {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .badge {
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 11px;
            gap: 2px;
        }

        .badge-value {
            font-size: 14px;
            font-weight: 600;
            color: var(--primary);
        }

        .badge-label {
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .connect-btn {
            padding: 8px 20px;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            border: none;
            color: white;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }

        .connect-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(102, 126, 234, 0.4);
        }

        .connect-btn:active {
            transform: translateY(0);
        }

        /* LEFT SIDEBAR */
        .left-sidebar {
            background: var(--bg-panel);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            padding: 20px 0;
            overflow-y: auto;
        }

        .nav-section {
            padding: 10px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .nav-section:last-child {
            border-bottom: none;
        }

        .nav-button {
            width: 100%;
            padding: 12px 20px;
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            text-align: left;
            font-size: 14px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-button:hover {
            color: var(--text-light);
            background: rgba(102, 126, 234, 0.1);
            padding-left: 24px;
        }

        .nav-button.active {
            color: var(--primary);
            background: rgba(102, 126, 234, 0.2);
            border-left: 3px solid var(--primary);
            padding-left: 17px;
        }

        /* CENTER AREA */
        .center-area {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr auto;
            gap: 10px;
            padding: 10px;
            overflow: hidden;
        }

        .video-container {
            grid-column: 1;
            grid-row: 1;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .video-container img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .map-container {
            grid-column: 2;
            grid-row: 1;
            background: var(--bg-panel);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        #mapCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* RIGHT SIDEBAR */
        .right-sidebar {
            background: var(--bg-panel);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            padding: 15px;
            overflow-y: auto;
            gap: 15px;
        }

        .panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 12px;
        }

        .panel-title {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 10px;
            display: block;
        }

        /* FSM STATE DISPLAY */
        .fsm-state-display {
            text-align: center;
            padding: 12px;
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid var(--primary);
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .fsm-state-name {
            font-size: 16px;
            font-weight: 600;
            color: var(--primary);
        }

        .fsm-state-value {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 2px;
        }

        /* FSM BUTTONS */
        .fsm-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }

        .state-btn {
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-muted);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .state-btn:hover:not(:disabled) {
            color: var(--text-light);
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .state-btn.active {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            border-color: var(--primary);
        }

        .state-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .state-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }

        .state-id {
            font-size: 12px;
            color: #718096;
        }

        /* MOVEMENT CONTROLS */
        .movement-panel {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: auto;
        }

        .speed-control {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .speed-label {
            font-size: 11px;
            color: var(--text-muted);
            display: flex;
            justify-content: space-between;
        }

        .speed-value {
            color: var(--primary);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            box-shadow: 0 0 8px rgba(102, 126, 234, 0.6);
        }

        /* MOVEMENT GRID */
        .movement-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin: 15px 0;
        }

        .move-btn {
            padding: 12px;
            background: rgba(102, 126, 234, 0.15);
            border: 2px solid rgba(102, 126, 234, 0.3);
            color: var(--text-light);
            border-radius: 6px;
            cursor: pointer;
            font-size: 20px;
            font-weight: 700;
            transition: all 0.15s;
            display: flex;
            align-items: center;
            justify-content: center;
            aspect-ratio: 1;
            min-height: 50px;
        }

        .move-btn:hover {
            color: white;
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.3);
            transform: scale(1.08);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.4);
        }

        .move-btn:active {
            background: var(--primary);
            color: white;
            border-color: var(--primary-dark);
            transform: scale(0.95);
        }

        .move-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .move-btn.stop-btn {
            background: rgba(245, 101, 101, 0.15);
            border-color: rgba(245, 101, 101, 0.3);
        }

        .move-btn.stop-btn:hover {
            border-color: #f56565;
            background: rgba(245, 101, 101, 0.3);
        }

        .move-btn.rotate-btn {
            grid-column: span 5;
            padding: 12px 16px;
            aspect-ratio: auto;
            min-height: 45px;
            font-size: 16px;
        }

        /* CONTENT VIEWS */
        .content-view {
            display: none;
            padding: 20px;
            overflow-y: auto;
            grid-column: 1 / -1;
            grid-row: 2;
            background: var(--bg-panel);
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-height: 500px;
        }

        .content-view.active {
            display: block;
        }

        /* MODAL */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-panel);
            border-radius: 8px;
            padding: 40px;
            max-width: 550px;
            width: 95%;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid var(--primary);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .modal-title {
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 30px;
            color: var(--primary);
            text-align: center;
        }

        .form-group {
            margin-bottom: 22px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-label {
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-light);
        }

        .form-input {
            padding: 14px 12px;
            background: rgba(255, 255, 255, 0.08);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: var(--text-light);
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .form-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
            font-size: 15px;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.15);
            box-shadow: 0 0 12px rgba(102, 126, 234, 0.3);
        }

        .form-input:disabled {
            background: rgba(255, 255, 255, 0.03);
            color: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }

        .select-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        select.form-input {
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23e0e0e0' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 36px;
            cursor: pointer;
        }

        select.form-input option {
            background: var(--bg-dark);
            color: var(--text-light);
            padding: 10px;
        }

        select.form-input option:checked {
            background: var(--primary);
            color: white;
        }

        .form-buttons {
            display: flex;
            gap: 12px;
            margin-top: 30px;
        }

        .form-buttons button {
            flex: 1;
            padding: 14px 16px;
            border: none;
            border-radius: 6px;
            font-weight: 700;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary), var(--primary-dark));
            color: white;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.08);
            color: var(--text-light);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
        }

        /* GESTURE BUTTONS */
        .gesture-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
        }

        .actions-layout {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
        }

        .actions-card {
            background: rgba(0, 0, 0, 0.25);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            padding: 12px;
        }

        .actions-card-title {
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .actions-row {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            flex-wrap: wrap;
        }

        .actions-list {
            display: grid;
            gap: 8px;
        }

        .action-row {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 8px;
            align-items: center;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 4px;
            padding: 8px;
        }

        .action-name {
            font-size: 13px;
            color: var(--text-light);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .action-rename {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .action-rename input {
            width: 120px;
        }

        .teach-status {
            font-size: 12px;
            color: var(--text-muted);
        }

        .teach-status.active {
            color: #f59e0b;
        }

        .mode-hint {
            font-size: 12px;
            color: var(--text-muted);
        }

        .mode-hint.warning {
            color: #f59e0b;
        }

        .gesture-btn {
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--text-light);
            border-radius: 4px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .gesture-btn:hover:not(:disabled) {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.1);
            transform: translateY(-2px);
        }

        .gesture-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .gesture-emoji {
            font-size: 24px;
            display: block;
            margin-bottom: 6px;
        }

        .gesture-name {
            font-size: 12px;
            font-weight: 600;
        }

        /* Network Mode Selector */
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 10px 0;
        }

        .radio-option {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .radio-option:hover {
            border-color: var(--primary);
            background: rgba(102, 126, 234, 0.05);
        }

        .radio-option input[type="radio"] {
            margin-top: 2px;
            cursor: pointer;
        }

        .radio-option input[type="radio"]:checked ~ .radio-label {
            color: var(--primary);
        }

        .radio-label {
            display: flex;
            flex-direction: column;
            gap: 4px;
            flex: 1;
        }

        .radio-label-title {
            font-weight: 600;
            font-size: 14px;
        }

        .radio-description {
            font-size: 12px;
            color: var(--text-muted);
        }

        /* Info Box (AP Mode Instructions) */
        .info-box {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 15px;
            font-size: 13px;
            margin: 10px 0;
        }

        .info-box strong {
            display: block;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .info-box code {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: var(--primary);
        }

        .info-box ol {
            margin: 10px 0 10px 20px;
        }

        /* Discovery Progress */
        .discovery-progress {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .progress-header {
            font-weight: 600;
            margin-bottom: 10px;
            color: var(--primary);
        }

        .progress-steps {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .progress-steps li {
            padding: 8px 0 8px 30px;
            position: relative;
            color: var(--text-muted);
            font-size: 13px;
        }

        .progress-steps li::before {
            content: '‚è±Ô∏è';
            position: absolute;
            left: 0;
            top: 8px;
        }

        .progress-steps li.active {
            color: var(--primary);
            font-weight: 500;
        }

        .progress-steps li.active::before {
            content: 'üîÑ';
            animation: spin 1s linear infinite;
        }

        .progress-steps li.complete::before {
            content: '‚úÖ';
        }

        .progress-steps li.failed::before {
            content: '‚ùå';
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* Status Indicator */
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 12px;
        }

        .status-indicator .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .status-indicator.online .status-dot {
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .status-indicator.offline .status-dot {
            background: var(--danger);
        }

        /* Button Loading State */
        .btn-primary.loading {
            opacity: 0.7;
            pointer-events: none;
            position: relative;
        }

        .btn-primary.loading::after {
            content: '';
            width: 14px;
            height: 14px;
            margin-left: 8px;
            border: 2px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            display: inline-block;
            animation: spin 0.6s linear infinite;
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* Help Text */
        .help-text {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 5px;
        }

        .help-text a {
            color: var(--primary);
            text-decoration: none;
        }

        .help-text a:hover {
            text-decoration: underline;
        }

        /* Error Box */
        .error-box {
            background: rgba(245, 101, 101, 0.1);
            border: 1px solid var(--danger);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
        }

        .error-box strong {
            color: var(--danger);
            display: block;
            margin-bottom: 10px;
        }

        .error-box ul {
            margin: 10px 0 10px 20px;
            font-size: 13px;
        }

        .error-box ul li {
            margin: 5px 0;
        }

        /* SCROLLBAR */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.3);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- TOP BAR -->
        <div class="top-bar">
            <div class="robot-info">
                <div class="robot-name" id="robotName">G1 Robot</div>
                <div class="status-badge offline" id="statusBadge">
                    <span class="status-dot"></span>
                    <span id="statusText">Offline</span>
                </div>
            </div>
            <div class="telemetry-badges">
                <div class="badge">
                    <div class="badge-label">Battery</div>
                    <div class="badge-value" id="batteryValue">--%</div>
                </div>
                <div class="badge">
                    <div class="badge-label">Voltage</div>
                    <div class="badge-value" id="voltageValue">--V</div>
                </div>
                <div class="badge">
                    <div class="badge-label">Temp</div>
                    <div class="badge-value" id="tempValue">--¬∞C</div>
                </div>
            </div>
            <button class="connect-btn" id="connectBtn" onclick="openConnectionModal()">Connect</button>
        </div>

        <!-- LEFT SIDEBAR -->
        <div class="left-sidebar">
            <div class="nav-section">
                <button class="nav-button" onclick="switchView('gestures')">üëã Gestures</button>
                <button class="nav-button" onclick="switchView('slam')">üó∫Ô∏è SLAM</button>
            </div>
            <div class="nav-section">
                <button class="nav-button" onclick="switchView('actions')">üé¨ Custom Actions</button>
                <button class="nav-button" onclick="switchView('status')">üìä Status</button>
            </div>
        </div>

        <!-- CENTER AREA -->
        <div class="center-area">
            <div class="video-container">
                <img id="videoStream" src="" alt="Video Stream" style="display:none;">
                <div id="videoPlaceholder" style="width:100%; height:100%; display:flex; align-items:center; justify-content:center; color: var(--text-muted);">
                    No video stream
                </div>
            </div>
            <div class="map-container">
                <canvas id="mapCanvas"></canvas>
            </div>
            
            <!-- CONTENT VIEWS MOVED HERE -->
            <div id="gestures-view" class="content-view">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">üëã Gestures</h2>
                    <button class="btn-secondary" onclick="closeView()">‚úï Close</button>
                </div>
                <div id="gestureModeHint" class="mode-hint" style="margin-bottom: 10px;">Available in WALK or RUN mode.</div>
                <div class="gesture-grid" id="gestureGrid"></div>
            </div>

            <div id="slam-view" class="content-view">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">üó∫Ô∏è SLAM Mapping</h2>
                    <button class="btn-secondary" onclick="closeView()">‚úï Close</button>
                </div>
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn-primary" onclick="startMapping()">‚ñ∂Ô∏è Start Mapping</button>
                    <button class="btn-secondary" onclick="stopMapping()">‚èπÔ∏è Stop Mapping</button>
                </div>
                <p style="color: var(--text-muted); font-size: 12px;">Point cloud displays in real-time. Odometry data only available during active mapping.</p>
            </div>

            <div id="actions-view" class="content-view">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">üé¨ Custom Actions</h2>
                    <button class="btn-secondary" onclick="closeView()">‚úï Close</button>
                </div>
                <div class="actions-layout">
                    <div class="actions-card">
                        <div class="actions-card-title">Record (Teach Mode)</div>
                        <div class="actions-row">
                            <button class="btn-secondary" id="enterTeachBtn" onclick="enterTeachMode()">Enter Teach Mode</button>
                            <button class="btn-secondary" id="exitTeachBtn" onclick="exitTeachMode()">Exit Teach Mode</button>
                            <span id="teachModeStatus" class="teach-status">Teach mode: off</span>
                        </div>
                        <div class="actions-row">
                            <input type="text" id="recordActionName" class="form-input" placeholder="Optional name (auto timestamp)" style="flex: 1;">
                            <button class="btn-primary" id="recordStartBtn" onclick="startTeachRecording()">Start</button>
                            <button class="btn-secondary" id="recordStopBtn" onclick="stopTeachRecording()">Stop &amp; Save</button>
                        </div>
                        <div class="actions-row" style="font-size: 12px; color: var(--text-muted);">
                            <span id="recordStatus">Idle</span>
                            <span id="recordTimer">00:00</span>
                            <span id="recordingName" style="color: var(--primary);"></span>
                        </div>
                        <div style="color: var(--text-muted); font-size: 11px;">
                            Start sends API 7110 and keeps it alive every second. Stop saves the action.
                        </div>
                    </div>
                    <div class="actions-card">
                        <div class="actions-card-title">Saved Actions</div>
                        <div class="actions-row">
                            <button class="btn-secondary" id="refreshActionsBtn" onclick="refreshTeachActions()">Refresh List</button>
                            <button class="btn-secondary" id="stopPlaybackBtn" onclick="stopCustomAction()">Stop Playback</button>
                        </div>
                        <div id="actionsModeHint" class="mode-hint" style="margin-bottom: 8px;">Available in WALK or RUN mode.</div>
                        <div id="actionsList" class="actions-list"></div>
                    </div>
                </div>
            </div>

            <div id="status-view" class="content-view">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">üìä Robot Status</h2>
                    <button class="btn-secondary" onclick="closeView()">‚úï Close</button>
                </div>
                <div style="display: grid; gap: 15px;">
                    <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">FSM State</div>
                        <div style="font-size: 16px; font-weight: 600; color: var(--primary); margin-top: 4px;" id="statusFsmId">0</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">FSM Mode</div>
                        <div style="font-size: 16px; font-weight: 600; color: var(--primary); margin-top: 4px;" id="statusFsmMode">0</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Battery Voltage</div>
                        <div style="font-size: 16px; font-weight: 600; color: var(--primary); margin-top: 4px;" id="statusVoltage">-- V</div>
                    </div>
                    <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1);">
                        <div style="font-size: 11px; color: var(--text-muted); text-transform: uppercase;">Temperature</div>
                        <div style="font-size: 16px; font-weight: 600; color: var(--primary); margin-top: 4px;" id="statusTemp">-- ¬∞C</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- RIGHT SIDEBAR -->
        <div class="right-sidebar">
            <!-- FSM STATE -->
            <div class="panel">
                <span class="panel-title">FSM State</span>
                <div class="fsm-state-display">
                    <div class="fsm-state-name" id="currentStateDisplay">ZERO_TORQUE</div>
                    <div class="fsm-state-value" id="currentStateValue">(ID: 0)</div>
                </div>
                <div class="fsm-buttons" id="fsmButtons"></div>
            </div>

            <!-- MOVEMENT CONTROLS -->
            <div class="panel movement-panel">
                <span class="panel-title">Movement</span>
                <div class="speed-control">
                    <div class="speed-label">
                        <span>Speed</span>
                        <span class="speed-value" id="speedValue">1.0x</span>
                    </div>
                    <input type="range" min="0.1" max="3.0" step="0.1" value="1.0" id="speedSlider" onchange="updateSpeed()">
                </div>
                <div class="movement-grid">
                    <!-- Row 1: Empty, Forward, Empty -->
                    <div></div>
                    <button class="move-btn" onclick="sendMovement(0.3, 0)" title="Forward (W)">‚¨ÜÔ∏è</button>
                    <div></div>
                    
                    <!-- Row 2: Left, Stop, Right -->
                    <button class="move-btn" onclick="sendMovement(0, 0.6)" title="Left (A)">‚¨ÖÔ∏è</button>
                    <button class="move-btn stop-btn" onclick="sendMovement(0, 0)" title="Stop (Space)">‚èπÔ∏è</button>
                    <button class="move-btn" onclick="sendMovement(0, -0.6)" title="Right (D)">‚û°Ô∏è</button>
                    
                    <!-- Row 3: Rotate Left, Backward, Rotate Right -->
                    <button class="move-btn" onclick="sendMovement(0, 0, 0.5)" title="Rotate Left (Q)">‚Ü∂</button>
                    <button class="move-btn" onclick="sendMovement(-0.3, 0)" title="Backward (S)">‚¨áÔ∏è</button>
                    <button class="move-btn" onclick="sendMovement(0, 0, -0.5)" title="Rotate Right (E)">‚Ü∑</button>
                    
                    <!-- Row 4: Emergency Stop spanning all 3 columns -->
                    <button class="move-btn stop-btn" onclick="setState('DAMP', true)" title="Emergency Stop - Enter DAMP Mode" style="grid-column: 1 / -1; background: rgba(220, 38, 38, 0.2); border-color: rgba(220, 38, 38, 0.5); aspect-ratio: auto;">üõë Emergency Stop</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; margin-top: 8px; font-size: 10px;">
                    <div style="color: var(--text-muted);">vx: <span id="velX" style="color: var(--primary);">0</span></div>
                    <div style="color: var(--text-muted);">vy: <span id="velY" style="color: var(--primary);">0</span></div>
                    <div style="color: var(--text-muted);">œâ: <span id="velOmega" style="color: var(--primary);">0</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- CONNECTION MODAL -->
    <div id="connectionModal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Connect to Robot</div>
            
            <!-- Network Mode Selection -->
            <div class="form-group">
                <label class="form-label">Connection Method</label>
                <div class="radio-group">
                    <label class="radio-option">
                        <input type="radio" name="connectionMode" value="sta" checked onchange="updateConnectionMode()">
                        <div class="radio-label">
                            <span class="radio-label-title">Home WiFi Network</span>
                            <span class="radio-description">Robot is on same WiFi as this computer</span>
                        </div>
                    </label>
                    <label class="radio-option">
                        <input type="radio" name="connectionMode" value="ap" onchange="updateConnectionMode()">
                        <div class="radio-label">
                            <span class="radio-label-title">Direct Connection (AP Mode)</span>
                            <span class="radio-description">Connect to robot's WiFi "G1_6937"</span>
                        </div>
                    </label>
                </div>
            </div>

            <!-- STA Mode: Robot Selection -->
            <div id="staMode" class="form-group">
                <label class="form-label">Select Robot</label>
                <select id="robotSelect" class="form-input" onchange="selectRobot()">
                    <option value="">-- Choose a robot --</option>
                </select>
                <div class="help-text" style="display: none;">Don't see your robot? <a href="#" onclick="event.preventDefault(); scanNetwork(); return false;">Scan network</a> or <a href="#" onclick="event.preventDefault(); showAddRobot(); return false;">add manually</a></div>
            </div>

            <!-- AP Mode: WiFi Check -->
            <div id="apMode" class="form-group" style="display: none;">
                <div class="info-box">
                    <strong>‚ÑπÔ∏è AP Mode Connection</strong>
                    <ol>
                        <li>Connect your computer to WiFi: <code id="apWifiName">G1_6937</code></li>
                        <li>Robot IP address: <code>192.168.12.1</code> (fixed)</li>
                    </ol>
                    <div id="wifiStatus" class="status-indicator">
                        <span class="status-dot"></span>
                        <span id="wifiStatusText">Checking WiFi connection...</span>
                    </div>
                </div>
            </div>

            <!-- Discovery Progress (hidden by default) -->
            <div id="discoveryProgress" class="discovery-progress" style="display: none;">
                <div class="progress-header">üîç Searching for robot...</div>
                <ul class="progress-steps">
                    <li id="step-multicast" class="pending">Trying multicast discovery...</li>
                    <li id="step-ap" class="pending">Checking AP mode (192.168.12.1)...</li>
                    <li id="step-network" class="pending">Scanning network...</li>
                </ul>
            </div>

            <!-- Add New Robot (collapsed by default) -->
            <div id="addRobotSection" class="form-group" style="display: none;">
                <label class="form-label">Add New Robot</label>
                <input type="text" id="newRobotNickname" class="form-input" placeholder="Nickname (e.g., Kitchen G1)" style="margin-bottom: 8px;">
                <input type="text" id="newRobotMac" class="form-input" placeholder="MAC Address (fc:23:cd:92:60:02)" style="margin-bottom: 8px;">
                <input type="text" id="newRobotSerial" class="form-input" placeholder="Serial Number (E21D1000PAHBMB06)" style="margin-bottom: 8px;">
                <div style="display: flex; gap: 8px;">
                    <button class="btn-secondary" style="flex: 1;" onclick="addRobot()">Add Robot</button>
                    <button class="btn-secondary" style="flex: 1;" onclick="hideAddRobot()">Cancel</button>
                </div>
            </div>

            <!-- Hidden fields for debugging -->
            <details style="margin: 15px 0; font-size: 12px;">
                <summary style="cursor: pointer; color: var(--text-muted);">Advanced Options</summary>
                <div class="form-group" style="margin-top: 10px;">
                    <label class="form-label">Robot IP (auto-discovered)</label>
                    <input type="text" id="robotIp" class="form-input" placeholder="Auto-discover" readonly>
                </div>
                <div class="form-group">
                    <label class="form-label">Serial Number</label>
                    <input type="text" id="robotSerial" class="form-input" placeholder="Serial Number" readonly>
                </div>
            </details>

            <div class="form-buttons">
                <button class="btn-primary" id="connectBtn" onclick="connectRobot()">
                    <span id="connectBtnText">Connect to Robot</span>
                </button>
                <button class="btn-secondary" onclick="closeConnectionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const G1_MAC = "fc:23:cd:92:60:02";
        const G1_SERIAL = "E21D1000PAHBMB06";
        const G1_NICKNAME = "G1_6937";
        
        let velocityScale = 1.0;
        let wsConnection = null;
        let currentRobot = null;
        let videoStreamInterval = null;
        let pointCloudInterval = null;
        // Pre-populate with your robot data
        let allRobots = [
            { nickname: "G1_6937", mac: "fc:23:cd:92:60:02", serial_number: "E21D1000PAHBMB06", ip: "192.168.86.2" }
        ];
        let connectedRobotMac = null;

        // FSM States with their IDs (must match backend FSMState enum names)
        const FSM_STATES = [
            { name: 'ZERO_TORQUE', value: 0, description: 'Motors Off' },
            { name: 'DAMP', value: 1, description: 'Safe Mode (Orange)' },
            { name: 'SQUAT', value: 2, description: 'Squat Position' },
            { name: 'SIT', value: 3, description: 'Sitting (Green)' },
            { name: 'LOCK_STANDING', value: 4, description: 'Standing Up' },
            { name: 'START', value: 200, description: 'Ready/Standing (Blue)' },
            { name: 'LOCK_STAND', value: 500, description: 'Walk Mode' },
            { name: 'STAND_UP', value: 702, description: 'Stand Up (from lying down)' },
            { name: 'SQUAT_TO_STAND', value: 706, description: 'Squat Down/Up (context-sensitive)' },
            { name: 'RUN', value: 801, description: 'Run Mode (Faster)' }
        ];

        let currentFsmState = null;
        let allowedTransitions = [];
        let buttonsDisabled = false;
        let targetState = null;
        let actionOriginState = null;

        const GESTURES = [
            // ArmTask gestures (simple)
            { emoji: "üëã", name: "WAVE_HAND" },
            { emoji: "üëãüîÑ", name: "WAVE_HAND_TURN" },
            { emoji: "ü§ù", name: "SHAKE_HAND_STAGE_1" },
            { emoji: "ü§ù‚úì", name: "SHAKE_HAND_STAGE_2" },
            
            // ArmGesture gestures (complex)
            { emoji: "üíã", name: "TWO_HAND_KISS" },
            { emoji: "üíãüëà", name: "LEFT_KISS" },
            { emoji: "üíãüëâ", name: "RIGHT_KISS" },
            { emoji: "üôå", name: "HANDS_UP" },
            { emoji: "üëè", name: "CLAP" },
            { emoji: "‚úã", name: "HIGH_FIVE" },
            { emoji: "ü§ó", name: "HUG" },
            { emoji: "‚ù§Ô∏è", name: "HEART" },
            { emoji: "‚ù§Ô∏èüëâ", name: "RIGHT_HEART" },
            { emoji: "üö´", name: "REJECT" },
            { emoji: "‚úãüëâ", name: "RIGHT_HAND_UP" },
            { emoji: "‚ò¢Ô∏è", name: "X_RAY" },
            { emoji: "üëãüòä", name: "FACE_WAVE" },
            { emoji: "üëã‚¨ÜÔ∏è", name: "HIGH_WAVE" },
            { emoji: "ü§ùüëâ", name: "SHAKE_HAND" }
        ];

        // Initialize on load
        window.addEventListener('DOMContentLoaded', () => {
            loadRobots();
            initializeGestures();
            setupKeyboardControls();
            connectWebSocket();
            initializePointCloudViewer();
            syncRobotConnectionState();  // NEW: Check actual backend state

            window.addEventListener('beforeunload', () => {
                if (connectedRobotMac && navigator.sendBeacon) {
                    navigator.sendBeacon('/api/disconnect');
                }
            });
        });

        // Sync connection state from backend on page load
        async function syncRobotConnectionState() {
            try {
                const response = await fetch('/api/robot/status');
                const status = await response.json();
                
                if (status.connected && status.robot) {
                    // Backend says we're connected - sync frontend state
                    console.log('Backend is connected, syncing frontend state');
                    connectedRobotMac = status.robot.mac || null;
                    updateConnectionStatus(true);
                    
                    // Update FSM display if state available
                    if (status.state) {
                        currentFsmState = status.state.fsm_state;
                        allowedTransitions = status.state.allowed_transitions || [];
                        updateFsmDisplay(status.state.fsm_state);
                        updateStateButtons();
                        updateGestureAvailability();
                        updateActionsAvailability();
                    }
                    
                    // Start video/lidar polling
                    startVideoStream();
                    startPointCloudPolling();
                } else {
                    // Not connected - ensure clean state
                    console.log('Backend not connected, ensuring clean state');
                    connectedRobotMac = null;
                    currentFsmState = null;
                    allowedTransitions = [];
                    updateConnectionStatus(false);
                    stopVideoStream();
                    stopPointCloudPolling();
                    updateGestureAvailability();
                    updateActionsAvailability();
                }
            } catch (e) {
                console.warn('Could not sync connection state:', e);
                // Assume not connected on error
                updateConnectionStatus(false);
                stopVideoStream();
                stopPointCloudPolling();
            }
        }

        // Robot Management
        async function loadRobots() {
            try {
                const response = await fetch('/api/robots');
                const data = await response.json();
                allRobots = data.robots || data; // Handle both formats
                populateRobotDropdown();
                localStorage.setItem('storedRobots', JSON.stringify(allRobots));
            } catch (e) {
                console.warn('Could not load robot list from API, using defaults + local storage');
                const stored = localStorage.getItem('storedRobots');
                if (stored) {
                    allRobots = JSON.parse(stored);
                } else {
                    // Ensure default robot is always available
                    allRobots = [
                        { nickname: "G1_6937", mac: "fc:23:cd:92:60:02", serial_number: "E21D1000PAHBMB06", ip: "192.168.86.2" }
                    ];
                    localStorage.setItem('storedRobots', JSON.stringify(allRobots));
                }
                populateRobotDropdown();
            }
        }

        function populateRobotDropdown() {
            const select = document.getElementById('robotSelect');
            select.innerHTML = '<option value="">-- Choose a robot --</option>';
            allRobots.forEach(r => {
                const opt = document.createElement('option');
                opt.value = r.mac;
                opt.textContent = `${r.nickname} (${r.mac})`;
                select.appendChild(opt);
            });
        }

        function selectRobot() {
            const mac = document.getElementById('robotSelect').value;
            const robot = allRobots.find(r => r.mac === mac);
            if (robot) {
                document.getElementById('robotIp').value = robot.ip || 'Auto-discover';
                document.getElementById('robotSerial').value = robot.serial_number || '';
            }
        }

        function addRobot() {
            const nickname = document.getElementById('newRobotNickname').value;
            const mac = document.getElementById('newRobotMac').value;
            const serial = document.getElementById('newRobotSerial').value;

            if (!nickname || !mac || !serial) {
                alert('Please fill in all fields');
                return;
            }

            fetch('/api/add_robot', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ nickname, mac, serial_number: serial })
            }).then(() => {
                loadRobots();
                document.getElementById('newRobotNickname').value = '';
                document.getElementById('newRobotMac').value = '';
                document.getElementById('newRobotSerial').value = '';
                hideAddRobot();
            }).catch(() => {
                const newRobot = { nickname, mac, serial_number: serial, ip: '' };
                if (!allRobots) allRobots = [];
                allRobots.push(newRobot);
                localStorage.setItem('storedRobots', JSON.stringify(allRobots));
                populateRobotDropdown();
                document.getElementById('newRobotNickname').value = '';
                document.getElementById('newRobotMac').value = '';
                document.getElementById('newRobotSerial').value = '';
                alert('Robot added successfully!');
                hideAddRobot();
            });
        }

        function showAddRobot() {
            document.getElementById('addRobotSection').style.display = 'block';
        }

        function hideAddRobot() {
            document.getElementById('addRobotSection').style.display = 'none';
            document.getElementById('newRobotNickname').value = '';
            document.getElementById('newRobotMac').value = '';
            document.getElementById('newRobotSerial').value = '';
        }

        // Connection Mode Management
        function updateConnectionMode() {
            const mode = document.querySelector('input[name="connectionMode"]:checked').value;
            console.log('Connection mode changed to:', mode);
            
            if (mode === 'ap') {
                // Show AP mode instructions, hide STA mode robot selection
                document.getElementById('staMode').style.display = 'none';
                document.getElementById('apMode').style.display = 'block';
                document.getElementById('discoveryProgress').style.display = 'none';
                
                // Check current WiFi status
                checkAPModeStatus();
            } else {
                // Show STA mode robot selection, hide AP mode instructions
                document.getElementById('staMode').style.display = 'block';
                document.getElementById('apMode').style.display = 'none';
                document.getElementById('discoveryProgress').style.display = 'none';
            }
        }

        // Check if computer is connected to robot's AP WiFi
        async function checkAPModeStatus() {
            try {
                const response = await fetch('/api/wifi/current');
                const data = await response.json();
                
                const wifiStatus = document.getElementById('wifiStatus');
                const wifiStatusText = document.getElementById('wifiStatusText');
                
                console.log('WiFi status:', data);
                
                if (data.ssid && data.ssid.includes('G1_')) {
                    wifiStatus.classList.add('online');
                    wifiStatus.classList.remove('offline');
                    wifiStatusText.textContent = `‚úì Connected to ${data.ssid}`;
                    
                    // Update AP WiFi name dynamically
                    document.getElementById('apWifiName').textContent = data.ssid;
                } else {
                    wifiStatus.classList.add('offline');
                    wifiStatus.classList.remove('online');
                    wifiStatusText.textContent = `‚úó Not connected to robot WiFi. Current: ${data.ssid || 'Unknown'}`;
                }
            } catch (e) {
                console.error('Failed to check WiFi status:', e);
                const wifiStatus = document.getElementById('wifiStatus');
                const wifiStatusText = document.getElementById('wifiStatusText');
                wifiStatus.classList.add('offline');
                wifiStatus.classList.remove('online');
                wifiStatusText.textContent = '‚úó Could not detect WiFi status';
            }
        }

        // Network scan with progress
        async function scanNetwork() {
            const progressDiv = document.getElementById('discoveryProgress');
            progressDiv.style.display = 'block';
            
            // Reset all steps
            ['multicast', 'ap', 'network'].forEach(step => {
                const el = document.getElementById(`step-${step}`);
                el.className = 'pending';
            });
            
            const steps = ['multicast', 'ap', 'network'];
            let currentStep = 0;
            
            // Animate progress
            const stepInterval = setInterval(() => {
                if (currentStep > 0) {
                    const prevEl = document.getElementById(`step-${steps[currentStep - 1]}`);
                    if (prevEl && prevEl.className === 'active') {
                        prevEl.className = 'complete';
                    }
                }
                if (currentStep < steps.length) {
                    document.getElementById(`step-${steps[currentStep]}`).className = 'active';
                    currentStep++;
                }
            }, 1500);
            
            try {
                const mac = document.getElementById('robotSelect').value || G1_MAC;
                console.log('Discovering robot with MAC:', mac);
                const response = await fetch(`/api/discover?mac=${mac}`);
                const data = await response.json();
                
                clearInterval(stepInterval);
                
                if (data.ip) {
                    // Mark all steps complete
                    steps.forEach(step => {
                        const el = document.getElementById(`step-${step}`);
                        if (el) el.className = 'complete';
                    });
                    
                    console.log('Robot discovered at:', data.ip);
                    
                    // Update robot IP in the list
                    const robot = allRobots.find(r => r.mac === mac);
                    if (robot) {
                        robot.ip = data.ip;
                        localStorage.setItem('storedRobots', JSON.stringify(allRobots));
                    }
                    
                    // Update UI
                    document.getElementById('robotIp').value = data.ip;
                    
                    // Show success message briefly
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                        alert(`‚úÖ Robot found at ${data.ip}`);
                    }, 1000);
                } else {
                    // Mark last active step as failed
                    if (currentStep > 0) {
                        document.getElementById(`step-${steps[currentStep - 1]}`).className = 'failed';
                    }
                    showDiscoveryError(data.error || 'Robot not found');
                }
            } catch (e) {
                clearInterval(stepInterval);
                console.error('Discovery error:', e);
                showDiscoveryError(e.message);
            }
        }

        function showDiscoveryError(message = '') {
            const progressDiv = document.getElementById('discoveryProgress');
            progressDiv.innerHTML = `
                <div class="error-box">
                    <strong>‚ùå Robot not found</strong>
                    <p>${message}</p>
                    <p><strong>Troubleshooting:</strong></p>
                    <ul>
                        <li>Is the robot powered on?</li>
                        <li>Are you connected to the same WiFi network?</li>
                        <li>Try Direct Connection (AP mode) instead</li>
                        <li>Check MAC address is correct: ${G1_MAC}</li>
                    </ul>
                    <button class="btn-secondary" onclick="hideDiscoveryError()" style="margin-top: 10px;">
                        Close
                    </button>
                </div>
            `;
        }

        function hideDiscoveryError() {
            const progressDiv = document.getElementById('discoveryProgress');
            progressDiv.style.display = 'none';
            progressDiv.innerHTML = `
                <div class="progress-header">üîç Searching for robot...</div>
                <ul class="progress-steps">
                    <li id="step-multicast" class="pending">Trying multicast discovery...</li>
                    <li id="step-ap" class="pending">Checking AP mode (192.168.12.1)...</li>
                    <li id="step-network" class="pending">Scanning network...</li>
                </ul>
            `;
        }

        // Connection
        async function connectRobot() {
            const connectBtn = document.getElementById('connectBtn');
            const connectBtnText = document.getElementById('connectBtnText');
            const mode = document.querySelector('input[name="connectionMode"]:checked').value;
            
            // Update button state
            connectBtn.classList.add('loading');
            connectBtn.disabled = true;
            connectBtnText.textContent = 'Connecting...';
            
            try {
                let robotIp;
                let robotMac;
                let serialNumber;
                
                if (mode === 'ap') {
                    // AP Mode: Use fixed IP
                    robotIp = '192.168.12.1';
                    robotMac = G1_MAC; // Use default or from selection if implemented
                    serialNumber = G1_SERIAL;
                    
                    console.log('AP mode connection to', robotIp);
                    
                } else {
                    // STA Mode: Discover IP
                    const selectedRobotMac = document.getElementById('robotSelect').value;
                    if (!selectedRobotMac) {
                        throw new Error('Please select a robot');
                    }
                    
                    const robot = allRobots.find(r => r.mac === selectedRobotMac);
                    if (!robot) {
                        throw new Error('Robot not found in list');
                    }
                    
                    robotMac = robot.mac;
                    serialNumber = robot.serial_number;
                    
                    // ALWAYS do discovery for STA mode (IPs can change with DHCP)
                    console.log('Discovering robot IP for MAC:', robotMac);
                    const progressDiv = document.getElementById('discoveryProgress');
                    progressDiv.style.display = 'block';
                    
                    // Reset steps
                    ['multicast', 'ap', 'network'].forEach(step => {
                        document.getElementById(`step-${step}`).className = 'pending';
                    });
                    
                    document.getElementById('step-multicast').className = 'active';
                    
                    const response = await fetch(`/api/discover?mac=${robotMac}`);
                    const data = await response.json();
                    
                    if (!data.ip) {
                        document.getElementById('step-network').className = 'failed';
                        throw new Error('Robot not found on network. Check power and WiFi.');
                    }
                    
                    robotIp = data.ip;
                    robot.ip = robotIp; // Update cache
                    localStorage.setItem('storedRobots', JSON.stringify(allRobots));
                    
                    // Mark steps complete
                    ['multicast', 'ap', 'network'].forEach(step => {
                        document.getElementById(`step-${step}`).className = 'complete';
                    });
                    
                    setTimeout(() => {
                        progressDiv.style.display = 'none';
                    }, 1000);
                    
                    console.log('Discovered robot at:', robotIp);
                }
                
                // Update readonly fields for debugging
                document.getElementById('robotIp').value = robotIp;
                document.getElementById('robotSerial').value = serialNumber;
                
                // Make connection request
                console.log(`Connecting to robot at ${robotIp} (MAC: ${robotMac}, SN: ${serialNumber}, Mode: ${mode})`);
                const response = await fetch(`/api/connect?mac=${robotMac}&serial_number=${serialNumber}&mode=${mode}`, {
                    method: 'POST'
                });
                const data = await response.json();
                
                if (data.success) {
                    connectedRobotMac = robotMac;
                    currentRobot = { mac: robotMac, serial_number: serialNumber, ip: robotIp };
                    const robot = allRobots.find(r => r.mac === robotMac);
                    document.getElementById('robotName').textContent = robot?.nickname || 'G1 Robot';
                    closeConnectionModal();
                    updateConnectionStatus(true);
                    
                    // CRITICAL: Extract initial state from response and render FSM buttons
                    if (data.state) {
                        console.log('Received initial state:', data.state);
                        currentFsmState = data.state.fsm_state_value;
                        
                        // Convert allowed transition names to values
                        allowedTransitions = data.state.allowed_transitions.map(name => {
                            const state = FSM_STATES.find(s => s.name === name);
                            return state ? state.value : null;
                        }).filter(v => v !== null);
                        
                        console.log('Set currentFsmState:', currentFsmState, 'allowedTransitions:', allowedTransitions);
                        
                        // Update the FSM display
                        updateFsmDisplay(data.state.fsm_state, data.state.fsm_state_value);
                        
                        // Render the state buttons
                        updateStateButtons();
                        updateGestureAvailability();
                        updateActionsAvailability();
                    }
                    
                    startVideoStream();
                    startPointCloudPolling();
                    
                    console.log('‚úÖ Connected successfully!');
                } else {
                    throw new Error(data.error || 'Connection failed');
                }
                
            } catch (e) {
                console.error('Connection error:', e);
                
                // Show user-friendly error
                let errorMsg = `Connection failed: ${e.message}\n\nTroubleshooting:\n`;
                errorMsg += '‚Ä¢ Check robot is powered on\n';
                errorMsg += '‚Ä¢ Verify WiFi connection\n';
                if (mode === 'sta') {
                    errorMsg += '‚Ä¢ Try Direct Connection (AP mode) instead';
                } else {
                    errorMsg += '‚Ä¢ Make sure you\'re connected to robot WiFi "G1_6937"';
                }
                
                alert(errorMsg);
                
            } finally {
                // Reset button
                connectBtn.classList.remove('loading');
                connectBtn.disabled = false;
                connectBtnText.textContent = 'Connect to Robot';
            }
        }

        function openConnectionModal() {
            document.getElementById('connectionModal').classList.add('active');
        }

        function closeConnectionModal() {
            document.getElementById('connectionModal').classList.remove('active');
        }

        async function disconnectRobot() {
            try {
                await fetch('/api/disconnect', { method: 'POST' });
            } catch (e) {
                console.warn('Disconnect request failed:', e);
            } finally {
                connectedRobotMac = null;
                currentRobot = null;
                updateConnectionStatus(false);
                stopVideoStream();
                stopPointCloudPolling();
            }
        }

        // WebSocket
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            wsConnection = new WebSocket(`${protocol}//${window.location.host}/ws`);

            wsConnection.onopen = () => console.log('WebSocket connected');
            wsConnection.onmessage = (event) => {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };
            wsConnection.onerror = (e) => console.error('WebSocket error:', e);
            wsConnection.onclose = () => {
                setTimeout(connectWebSocket, 2000);
            };
        }

        function handleWebSocketMessage(msg) {
            if (msg.type === 'state_changed') {
                const newStateValue = msg.data.fsm_state_value;
                const newStateName = msg.data.fsm_state;
                const oldState = currentFsmState;
                
                // Update the robot state display
                currentFsmState = newStateValue;  // Use VALUE not NAME
                
                // Convert allowed transition names to values
                allowedTransitions = (msg.data.allowed_transitions || []).map(name => {
                    const state = FSM_STATES.find(s => s.name === name);
                    return state ? state.value : null;
                }).filter(v => v !== null);
                
                updateStatus(msg.data);
                updateFsmDisplay(newStateName, newStateValue);
                updateGestureAvailability();
                updateActionsAvailability();
                
                // SAFETY-CRITICAL: Re-enable buttons only when reaching stable endpoint state
                if (newStateValue !== null && newStateValue !== oldState) {
                    // Find state names for comparison
                    const targetStateObj = FSM_STATES.find(s => s.name === targetState);
                    const targetStateValue = targetStateObj ? targetStateObj.value : null;
                    
                    if (buttonsDisabled && targetStateValue !== null && newStateValue === targetStateValue) {
                        console.log(`‚úì Reached target state: ${newStateName} - RE-ENABLING BUTTONS`);
                        buttonsDisabled = false;
                        targetState = null;
                        actionOriginState = null;
                    } else if (buttonsDisabled && targetStateValue !== null) {
                        console.log(`‚Üí Transitioning through ${newStateName}, target: ${targetState}`);
                    } else if (buttonsDisabled && !targetState) {
                        const stableStates = [0, 1, 200, 500, 4, 801];  // ZERO_TORQUE, DAMP, START, LOCK_STAND, LOCK_STANDING, RUN
                        const isStableState = stableStates.includes(newStateValue);
                        const isActionComplete = actionOriginState !== null ? (newStateValue !== actionOriginState) : true;
                        
                        if (isStableState && isActionComplete) {
                            console.log(`‚úì Action complete: ${newStateName} - RE-ENABLING BUTTONS`);
                            buttonsDisabled = false;
                            actionOriginState = null;
                        }
                    }
                }
                
                // ALWAYS update button state to reflect current state and allowed transitions
                updateStateButtons();
            } else if (msg.type === 'connection_changed') {
                const connected = !!msg.data?.connected;
                if (!connected) {
                    connectedRobotMac = null;
                    currentRobot = null;
                    stopVideoStream();
                    stopPointCloudPolling();
                }
                updateConnectionStatus(connected);
            } else if (msg.type === 'battery_updated') {
                updateBattery(msg.data);
            } else if (msg.type === 'lidar_cloud') {
                updatePointCloud(msg.data);
            }
        }

        function updateConnectionStatus(connected) {
            const badge = document.getElementById('statusBadge');
            const text = document.getElementById('statusText');
            const connectBtn = document.getElementById('connectBtn');
            if (connected) {
                badge.classList.remove('offline');
                text.textContent = 'Online';
                if (connectBtn) {
                    connectBtn.textContent = 'Disconnect';
                    connectBtn.onclick = disconnectRobot;
                }
            } else {
                badge.classList.add('offline');
                text.textContent = 'Offline';
                stopVideoStream();
                stopPointCloudPolling();
                if (connectBtn) {
                    connectBtn.textContent = 'Connect';
                    connectBtn.onclick = openConnectionModal;
                }
            }
        }

        // FSM State Management
        function updateFsmDisplay(stateName) {
            const state = FSM_STATES.find(s => s.name === stateName);
            if (state) {
                document.getElementById('currentStateDisplay').textContent = state.name;
                document.getElementById('currentStateValue').textContent = `(ID: ${state.value})`;
                document.getElementById('statusFsmId').textContent = state.value;
            }
        }

        function updateStateButtons() {
            const container = document.getElementById('fsmButtons');
            if (!container) {
                console.error('fsmButtons container not found!');
                return;
            }
            
            // Check if we have FSM state data (null/undefined check, not falsy check since 0 is valid state)
            if (currentFsmState === null || currentFsmState === undefined) {
                console.log('No currentFsmState - buttons hidden');
                container.innerHTML = '';
                return;
            }
            
            console.log(`Updating buttons: currentFsmState=${currentFsmState}, transitions=${JSON.stringify(allowedTransitions)}`);
            
            container.innerHTML = '';
            
            // Ensure allowedTransitions is an array
            const transitions = Array.isArray(allowedTransitions) ? allowedTransitions : [];
            
            FSM_STATES.forEach((state) => {
                const button = document.createElement('button');
                button.className = 'state-btn';
                
                // Check if this is the current state (compare VALUES, not names)
                const isCurrent = state.value === currentFsmState;
                if (isCurrent) {
                    button.classList.add('active');
                }
                
                // Check if transition is allowed (compare VALUES, not names)
                const isAllowed = transitions.includes(state.value);
                
                // SAFETY-FIRST: During transition (buttonsDisabled), disable ALL buttons except current for visual reference
                if (buttonsDisabled) {
                    button.disabled = true;
                    button.classList.add('invalid');
                    button.style.opacity = isCurrent ? '0.8' : '0.3';
                } else if (!isAllowed && !isCurrent) {
                    // Not transitioning, but this state is not allowed from current state
                    button.classList.add('invalid');
                    button.disabled = true;
                    button.style.opacity = '0.5';
                } else {
                    // Either current state or valid transition - enable
                    button.style.opacity = '1';
                }
                
                // User-friendly display names
                let displayName = state.name;
                switch(state.name) {
                    case 'LOCK_STAND':
                        displayName = 'WALK';
                        break;
                    case 'LOCK_STANDING':
                        displayName = 'STAND UP';
                        break;
                    case 'SQUAT_TO_STAND':
                        const currentStateObj = FSM_STATES.find(s => s.value === currentFsmState);
                        const currentStateValue = currentStateObj ? currentStateObj.value : null;
                        displayName = (currentStateValue === 0 || currentStateValue === 1) ? 'SQUAT UP' : 'SQUAT DOWN';
                        break;
                    case 'STAND_UP':
                        displayName = 'STAND UP';
                        break;
                }
                
                button.innerHTML = `
                    <div class="state-name">${displayName.replace(/_/g, ' ')}</div>
                    <div class="state-id">ID: ${state.value}</div>
                `;
                
                if (!button.disabled) {
                    button.onclick = () => setState(state.name);
                }
                
                container.appendChild(button);
            });
            
            console.log(`‚úÖ Rendered ${FSM_STATES.length} state buttons`);
        }

        async function setState(stateName, isEmergency = false) {
            if (!connectedRobotMac) {
                console.error('Not connected to robot');
                return;
            }
            
            // Emergency stop has priority - bypass button disable check
            if (isEmergency) {
                console.warn('üö® EMERGENCY STOP - Bypassing normal checks');
            } else if (buttonsDisabled) {
                console.log('Buttons disabled, ignoring click');
                return;
            }
            
            // Prevent clicking on current state (no transition needed)
            const targetStateObj = FSM_STATES.find(s => s.name === stateName);
            if (targetStateObj && targetStateObj.value === currentFsmState) {
                console.log(`Already in ${stateName}, ignoring click`);
                return;
            }
            
            // Disable all buttons during transition
            buttonsDisabled = true;
            
            // CRITICAL: States 702 (STAND_UP) and 706 (SQUAT_TO_STAND) are ACTIONS, not final states
            const isActionState = stateName === 'STAND_UP' || stateName === 'SQUAT_TO_STAND';
            
            if (isActionState) {
                targetState = null;
                actionOriginState = currentFsmState;
            } else {
                targetState = stateName;
                actionOriginState = null;
            }
            
            updateStateButtons();
            
            try {
                const response = await fetch(`/api/set_state?state_name=${stateName}`, {
                    method: 'POST'
                });
                
                const data = await response.json();
                
                if (!data.success) {
                    console.error('Transition failed:', data.error);
                    buttonsDisabled = false;
                    targetState = null;
                    actionOriginState = null;
                    updateStateButtons();
                }
            } catch (error) {
                console.error('State change error:', error);
                buttonsDisabled = false;
                updateStateButtons();
            }
        }

        // Movement
        function updateSpeed() {
            velocityScale = parseFloat(document.getElementById('speedSlider').value);
            document.getElementById('speedValue').textContent = `${velocityScale.toFixed(1)}x`;
        }

        async function sendMovement(vx, vy, omega = 0) {
            const scaled_vx = vx * velocityScale;
            const scaled_vy = vy * velocityScale;
            const scaled_omega = omega * velocityScale;

            document.getElementById('velX').textContent = scaled_vx.toFixed(2);
            document.getElementById('velY').textContent = scaled_vy.toFixed(2);
            document.getElementById('velOmega').textContent = scaled_omega.toFixed(2);

            try {
                await fetch('/api/move', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        vx: scaled_vx,
                        vy: scaled_vy,
                        omega: scaled_omega
                    })
                });
            } catch (e) {
                console.error('Move error:', e);
            }
        }

        // Keyboard Controls
        function setupKeyboardControls() {
            const keysPressed = {};

            window.addEventListener('keydown', (e) => {
                // Ignore if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                keysPressed[e.key.toLowerCase()] = true;
                processKeyboardMovement(keysPressed);
            });

            window.addEventListener('keyup', (e) => {
                // Ignore if user is typing in an input field
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                    return;
                }
                
                keysPressed[e.key.toLowerCase()] = false;
                processKeyboardMovement(keysPressed);
            });
        }

        function processKeyboardMovement(keys) {
            let vx = 0, vy = 0, omega = 0;

            if (keys['w']) vx += 0.3;
            if (keys['s']) vx -= 0.3;
            if (keys['a']) vy += 0.6;
            if (keys['d']) vy -= 0.6;
            if (keys['q']) omega += 0.5;
            if (keys['e']) omega -= 0.5;
            if (keys[' ']) { vx = vy = omega = 0; }

            // CRITICAL: ALWAYS send movement command, even when all zeros
            // This ensures robot stops when keys are released
            sendMovement(vx, vy, omega);
        }

        // Gestures
        function initializeGestures() {
            const grid = document.getElementById('gestureGrid');
            GESTURES.forEach(g => {
                const btn = document.createElement('button');
                btn.className = 'gesture-btn';
                btn.innerHTML = `<span class="gesture-emoji">${g.emoji}</span><span class="gesture-name">${g.name}</span>`;
                btn.onclick = () => executeGesture(g.name);
                grid.appendChild(btn);
            });
            updateGestureAvailability();
        }

        // Custom Actions (Teach Mode)
        const RECORD_MAX_SECONDS = 20;
        const ACTION_ALLOWED_STATES = [500, 801]; // WALK (LOCK_STAND) or RUN
        let teachModeActive = false;
        let recordTimerInterval = null;
        let recordStopTimeout = null;
        let recordStartTime = null;
        let gestureExecuting = false;  // Track if gesture/action is running

        async function executeGesture(name) {
            if (!isActionModeAllowed()) {
                alert('Gestures are only available in WALK or RUN mode.');
                return;
            }
            
            if (gestureExecuting) {
                console.warn('Gesture blocked - another gesture is already executing');
                return;
            }
            
            try {
                gestureExecuting = true;
                setGestureButtonsEnabled(false);
                console.log(`‚è≥ Executing gesture: ${name}...`);
                
                const response = await fetch('/api/gesture', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ gesture_name: name })
                });
                const data = await response.json();
                if (!data.success) {
                    console.error('Gesture failed:', data.error || data.message);
                    alert(`Gesture failed: ${data.error || data.message}`);
                } else {
                    console.log(`‚úÖ Gesture ${name} completed successfully`);
                }
            } catch (e) {
                console.error('Gesture error:', e);
                alert('Gesture error: ' + e.message);
            } finally {
                gestureExecuting = false;
                setGestureButtonsEnabled(true);
            }
        }
        
        function setGestureButtonsEnabled(enabled) {
            // Disable/enable gesture buttons
            const gestureButtons = document.querySelectorAll('#gestureGrid .gesture-btn');
            gestureButtons.forEach(btn => {
                if (enabled && isActionModeAllowed()) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                } else {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                }
            });
            
            // Also disable/enable action Play buttons
            const playButtons = document.querySelectorAll('.action-play-btn');
            playButtons.forEach(btn => {
                if (enabled && isActionModeAllowed()) {
                    btn.disabled = false;
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                } else {
                    btn.disabled = true;
                    btn.style.opacity = '0.5';
                    btn.style.cursor = 'not-allowed';
                }
            });
        }

        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60).toString().padStart(2, '0');
            const secs = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${mins}:${secs}`;
        }

        function setTeachModeStatus(active) {
            teachModeActive = active;
            const statusEl = document.getElementById('teachModeStatus');
            if (!statusEl) return;
            statusEl.textContent = active ? 'Teach mode: ON (arms compliant)' : 'Teach mode: off';
            statusEl.classList.toggle('active', active);
        }

        function isActionModeAllowed() {
            return ACTION_ALLOWED_STATES.includes(currentFsmState);
        }

        function updateGestureAvailability() {
            const allowed = isActionModeAllowed();
            const hint = document.getElementById('gestureModeHint');
            if (hint) {
                hint.textContent = allowed ? 'Available in WALK or RUN mode.' : 'Switch to WALK or RUN mode to use gestures.';
                hint.classList.toggle('warning', !allowed);
            }

            // Use the new helper that respects gesture execution state
            setGestureButtonsEnabled(allowed && !gestureExecuting);
        }

        function updateActionsAvailability() {
            const allowed = isActionModeAllowed();
            const hint = document.getElementById('actionsModeHint');
            if (hint) {
                hint.textContent = allowed ? 'Available in WALK or RUN mode.' : 'Switch to WALK or RUN mode to use custom actions.';
                hint.classList.toggle('warning', !allowed);
            }

            const controlIds = [
                'enterTeachBtn',
                'exitTeachBtn',
                'recordStartBtn',
                'recordStopBtn',
                'refreshActionsBtn',
                'stopPlaybackBtn'
            ];

            controlIds.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                el.disabled = !allowed;
                el.classList.toggle('invalid', !allowed);
                el.style.opacity = allowed ? '1' : '0.5';
            });

            document.querySelectorAll('#actionsList .action-row button').forEach(btn => {
                btn.disabled = !allowed;
                btn.classList.toggle('invalid', !allowed);
                btn.style.opacity = allowed ? '1' : '0.6';
            });

            document.querySelectorAll('#actionsList .action-row input').forEach(input => {
                input.disabled = !allowed;
            });
        }

        async function enterTeachMode() {
            const confirmText = 'Enter Teach Mode?\n\n‚ö†Ô∏è WARNING: Arms will go limp!\n\nThis will disable motor torque so you can move the arms by hand.\n\nMake sure robot is stable and won\'t fall.';
            if (!confirm(confirmText)) return;

            try {
                // Set balance mode to 0 (zero torque / compliant mode)
                const response = await fetch('/api/balance_mode', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 0 })
                });
                const data = await response.json();
                if (!data.success) {
                    alert(data.error || 'Failed to enter teach mode');
                    return;
                }
                setTeachModeStatus(true);
                console.log('‚úÖ Entered teach mode (balance_mode=0)');
            } catch (e) {
                console.error('Enter teach mode error:', e);
                alert('Failed to enter teach mode: ' + e.message);
            }
        }

        async function exitTeachMode() {
            const confirmText = 'Exit Teach Mode?\n\nArms will return to normal motor control.';
            if (!confirm(confirmText)) return;

            try {
                // Set balance mode to 1 (normal motor control)
                const response = await fetch('/api/balance_mode', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 1 })
                });
                const data = await response.json();
                if (!data.success) {
                    alert(data.error || 'Failed to exit teach mode');
                    return;
                }
                setTeachModeStatus(false);
                console.log('‚úÖ Exited teach mode (balance_mode=1)');
            } catch (e) {
                console.error('Exit teach mode error:', e);
                alert('Failed to exit teach mode: ' + e.message);
            }
        }

        async function startTeachRecording() {
            if (!isActionModeAllowed()) {
                alert('Teach recording is only available in WALK or RUN mode.');
                return;
            }
            const nameInput = document.getElementById('recordActionName');
            const actionName = nameInput.value.trim();
            const statusEl = document.getElementById('recordStatus');
            const timerEl = document.getElementById('recordTimer');
            const nameEl = document.getElementById('recordingName');

            try {
                const response = await fetch('/api/teach/record/start', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action_name: actionName })
                });
                const data = await response.json();

                if (!data.success) {
                    alert(data.error || 'Failed to start recording');
                    return;
                }

                nameEl.textContent = data.action_name || '';
                statusEl.textContent = `Recording (max ${RECORD_MAX_SECONDS}s)...`;
                recordStartTime = Date.now();
                timerEl.textContent = '00:00';

                if (recordTimerInterval) clearInterval(recordTimerInterval);
                if (recordStopTimeout) clearTimeout(recordStopTimeout);

                recordTimerInterval = setInterval(() => {
                    const elapsed = (Date.now() - recordStartTime) / 1000;
                    if (elapsed >= RECORD_MAX_SECONDS) {
                        stopTeachRecording();
                        return;
                    }
                    timerEl.textContent = formatDuration(elapsed);
                }, 500);

                recordStopTimeout = setTimeout(() => {
                    stopTeachRecording();
                }, RECORD_MAX_SECONDS * 1000);
            } catch (e) {
                console.error('Start recording error:', e);
                alert('Failed to start recording');
            }
        }

        async function stopTeachRecording() {
            if (!isActionModeAllowed()) {
                alert('Teach recording is only available in WALK or RUN mode.');
                return;
            }
            const statusEl = document.getElementById('recordStatus');
            const timerEl = document.getElementById('recordTimer');

            try {
                const response = await fetch('/api/teach/record/stop', { method: 'POST' });
                const data = await response.json();

                if (!data.success) {
                    alert(data.error || 'Failed to stop recording');
                    return;
                }

                statusEl.textContent = 'Saved';
                if (recordTimerInterval) {
                    clearInterval(recordTimerInterval);
                    recordTimerInterval = null;
                }
                if (recordStopTimeout) {
                    clearTimeout(recordStopTimeout);
                    recordStopTimeout = null;
                }
                timerEl.textContent = '00:00';
                refreshTeachActions();
            } catch (e) {
                console.error('Stop recording error:', e);
                alert('Failed to stop recording');
            }
        }

        async function refreshTeachActions() {
            try {
                const response = await fetch('/api/custom_action/robot_list');
                const data = await response.json();
                const list = document.getElementById('actionsList');
                list.innerHTML = '';

                const actions = data.custom_actions || [];
                if (!actions.length) {
                    const empty = document.createElement('div');
                    empty.style.color = 'var(--text-muted)';
                    empty.style.fontSize = '12px';
                    empty.textContent = 'No custom actions found.';
                    list.appendChild(empty);
                    return;
                }

                actions.forEach(action => {
                    // Extract action name from object (API returns {name: "...", time: ...})
                    const actionName = typeof action === 'string' ? action : action.name;
                    const actionTime = typeof action === 'object' ? action.time : null;
                    
                    const row = document.createElement('div');
                    row.className = 'action-row';

                    const name = document.createElement('div');
                    name.className = 'action-name';
                    name.textContent = actionName + (actionTime ? ` (${actionTime.toFixed(1)}s)` : '');

                    const playBtn = document.createElement('button');
                    playBtn.className = 'btn-primary action-play-btn';  // Add class for easy selection
                    playBtn.textContent = 'Play';
                    playBtn.onclick = () => playCustomAction(actionName);

                    const renameWrap = document.createElement('div');
                    renameWrap.className = 'action-rename';
                    const renameInput = document.createElement('input');
                    renameInput.type = 'text';
                    renameInput.className = 'form-input';
                    renameInput.placeholder = 'New name';
                    const renameBtn = document.createElement('button');
                    renameBtn.className = 'btn-secondary';
                    renameBtn.textContent = 'Rename';
                    renameBtn.onclick = () => renameTeachAction(actionName, renameInput.value.trim());

                    renameWrap.appendChild(renameInput);
                    renameWrap.appendChild(renameBtn);

                    row.appendChild(name);
                    row.appendChild(playBtn);
                    row.appendChild(renameWrap);
                    list.appendChild(row);
                });
                updateActionsAvailability();
            } catch (e) {
                console.error('Load actions error:', e);
            }
        }

        async function playCustomAction(actionName) {
            if (!isActionModeAllowed()) {
                alert('Custom actions are only available in WALK or RUN mode.');
                return;
            }
            
            if (gestureExecuting) {
                console.warn('Action blocked - another gesture/action is already executing');
                alert('Please wait for the current action to finish');
                return;
            }
            
            try {
                gestureExecuting = true;
                setGestureButtonsEnabled(false);
                console.log(`‚è≥ Playing custom action: ${actionName}...`);
                
                const response = await fetch('/api/custom_action/execute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action_name: actionName })
                });
                const data = await response.json();
                if (!data.success) {
                    alert(data.error || 'Failed to play action');
                } else {
                    console.log(`‚úÖ Custom action ${actionName} completed successfully`);
                }
            } catch (e) {
                console.error('Play action error:', e);
                alert('Play action error: ' + e.message);
            } finally {
                gestureExecuting = false;
                setGestureButtonsEnabled(true);
            }
        }

        async function stopCustomAction() {
            if (!isActionModeAllowed()) {
                alert('Custom actions are only available in WALK or RUN mode.');
                return;
            }
            try {
                const response = await fetch('/api/custom_action/stop', { method: 'POST' });
                const data = await response.json();
                if (!data.success) {
                    alert(data.error || 'Failed to stop action');
                }
            } catch (e) {
                console.error('Stop action error:', e);
            }
        }

        async function renameTeachAction(oldName, newName) {
            if (!isActionModeAllowed()) {
                alert('Custom actions are only available in WALK or RUN mode.');
                return;
            }
            if (!newName) {
                alert('New name required');
                return;
            }

            try {
                const response = await fetch('/api/teach/rename', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ old_name: oldName, new_name: newName })
                });
                const data = await response.json();
                if (!data.success) {
                    alert(data.error || 'Failed to rename action');
                    return;
                }
                refreshTeachActions();
            } catch (e) {
                console.error('Rename action error:', e);
            }
        }

        // SLAM
        async function startMapping() {
            try {
                const response = await fetch('/api/slam/start', { method: 'POST' });
                console.log('Mapping started');
            } catch (e) {
                console.error('Start mapping error:', e);
            }
        }

        async function stopMapping() {
            try {
                const response = await fetch('/api/slam/stop', { method: 'POST' });
                console.log('Mapping stopped');
            } catch (e) {
                console.error('Stop mapping error:', e);
            }
        }

        // Telemetry
        function updateBattery(data) {
            if (data.soc !== undefined) {
                document.getElementById('batteryValue').textContent = data.soc + '%';
            }
            if (data.bmsvoltage !== undefined) {
                document.getElementById('voltageValue').textContent = (data.bmsvoltage / 1000).toFixed(1) + 'V';
                document.getElementById('statusVoltage').textContent = (data.bmsvoltage / 1000).toFixed(1) + ' V';
            }
            if (data.temperature !== undefined) {
                document.getElementById('tempValue').textContent = data.temperature + '¬∞C';
                document.getElementById('statusTemp').textContent = data.temperature + ' ¬∞C';
            }
        }

        function updateStatus(state) {
            if (state.fsm_id !== undefined) {
                updateFsmDisplay(state.fsm_id, state.fsm_mode || 0);
            }
        }

        // Video Stream
        function startVideoStream() {
            if (!connectedRobotMac || videoStreamInterval) {
                return;
            }
            const img = document.getElementById('videoStream');
            const placeholder = document.getElementById('videoPlaceholder');
            if (placeholder) {
                placeholder.style.display = 'none';
            }
            img.style.display = 'block';

            videoStreamInterval = setInterval(() => {
                if (!connectedRobotMac) {
                    stopVideoStream();
                    return;
                }
                img.src = `/api/video/stream?t=${Date.now()}`;
            }, 100);
        }

        function stopVideoStream() {
            if (videoStreamInterval) {
                clearInterval(videoStreamInterval);
                videoStreamInterval = null;
            }
            const img = document.getElementById('videoStream');
            const placeholder = document.getElementById('videoPlaceholder');
            if (img) {
                img.src = '';
                img.style.display = 'none';
            }
            if (placeholder) {
                placeholder.style.display = 'flex';
            }
        }

        // Point Cloud Viewer
        let scene, camera, renderer, pointCloudMesh;

        function initializePointCloudViewer() {
            const canvas = document.getElementById('mapCanvas');
            if (!canvas) return;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0f1419);

            camera = new THREE.PerspectiveCamera(
                75,
                canvas.clientWidth / canvas.clientHeight,
                0.1,
                1000
            );
            camera.position.set(0, 2, 3);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Grid
            const gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            scene.add(gridHelper);

            // Axes
            const axesHelper = new THREE.AxesHelper(2);
            scene.add(axesHelper);

            // Lighting
            const light = new THREE.PointLight(0xffffff, 1);
            light.position.set(10, 10, 10);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x808080));

            // Point cloud placeholder
            const geometry = new THREE.BufferGeometry();
            const material = new THREE.PointsMaterial({ size: 0.02, sizeAttenuation: true });
            pointCloudMesh = new THREE.Points(geometry, material);
            scene.add(pointCloudMesh);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                const width = canvas.clientWidth;
                const height = canvas.clientHeight;
                camera.aspect = width / height;
                camera.updateProjectionMatrix();
                renderer.setSize(width, height);
            });

            // Start polling only after connection
            // (startPointCloudPolling is called after connect)
        }

        function startPointCloudPolling() {
            if (pointCloudInterval) {
                return;
            }
            pointCloudInterval = setInterval(updatePointCloud, 100);
        }

        function stopPointCloudPolling() {
            if (pointCloudInterval) {
                clearInterval(pointCloudInterval);
                pointCloudInterval = null;
            }
            if (pointCloudMesh) {
                pointCloudMesh.geometry.dispose();
                pointCloudMesh.geometry = new THREE.BufferGeometry();
            }
        }

        async function updatePointCloud() {
            if (!connectedRobotMac) {
                return;
            }
            try {
                const response = await fetch('/api/lidar/pointcloud');
                const data = await response.json();

                if (data.points && data.points.length > 0) {
                    const positions = new Float32Array(data.points.flat());
                    const colors = new Uint8Array(data.points.length * 3);

                    // Color by height
                    for (let i = 0; i < data.points.length; i++) {
                        const z = data.points[i][2] || 0;
                        const hue = Math.max(0, Math.min(1, (z + 2) / 4));
                        const rgb = hslToRgb(hue, 0.8, 0.5);
                        colors[i * 3] = rgb[0];
                        colors[i * 3 + 1] = rgb[1];
                        colors[i * 3 + 2] = rgb[2];
                    }

                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3, true));

                    const material = new THREE.PointsMaterial({
                        size: 0.02,
                        sizeAttenuation: true,
                        vertexColors: true
                    });

                    scene.remove(pointCloudMesh);
                    pointCloudMesh = new THREE.Points(geometry, material);
                    scene.add(pointCloudMesh);
                }
            } catch (e) {
                // Silently fail - no point cloud data yet
            }
        }

        function hslToRgb(h, s, l) {
            const c = (1 - Math.abs(2 * l - 1)) * s;
            const hp = h * 6;
            const x = c * (1 - Math.abs((hp % 2) - 1));
            let r, g, b;

            if (hp < 1) [r, g, b] = [c, x, 0];
            else if (hp < 2) [r, g, b] = [x, c, 0];
            else if (hp < 3) [r, g, b] = [0, c, x];
            else if (hp < 4) [r, g, b] = [0, x, c];
            else if (hp < 5) [r, g, b] = [x, 0, c];
            else [r, g, b] = [c, 0, x];

            const m = l - c / 2;
            return [
                Math.round((r + m) * 255),
                Math.round((g + m) * 255),
                Math.round((b + m) * 255)
            ];
        }

        // View Switching
        function switchView(view) {
            // Close all content views first
            document.querySelectorAll('.content-view').forEach(v => v.classList.remove('active'));
            // Open the selected view
            document.getElementById(view + '-view').classList.add('active');
            
            // Update nav button active state
            document.querySelectorAll('.nav-button').forEach(b => b.classList.remove('active'));
            event.target.classList.add('active');

            if (view === 'actions') {
                refreshTeachActions();
            }
        }
        
        function closeView() {
            // Close all content views
            document.querySelectorAll('.content-view').forEach(v => v.classList.remove('active'));
        }
    </script>
</body>
</html>
